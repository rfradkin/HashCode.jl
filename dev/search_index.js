var documenterSearchIndex = {"docs":
[{"location":"discussion/#Implementation-and-Performance","page":"Implementation and Performance","title":"Implementation and Performance","text":"","category":"section"},{"location":"discussion/#Implementation","page":"Implementation and Performance","title":"Implementation","text":"","category":"section"},{"location":"discussion/","page":"Implementation and Performance","title":"Implementation and Performance","text":"Our algorithm works by first trying to separate the cars and then allowing them to go on an optimized random walk in order to conver the most ground possible. ","category":"page"},{"location":"discussion/","page":"Implementation and Performance","title":"Implementation and Performance","text":"First, we identify the nodes that are the furthest, by latitude and longitude, in each of the cardinal direction (north, east, south, west, northeast, northwest, southeast, southwest). Next, we use djikstras algorithm to find the shortest path from the starting node to each of these furthest nodes. From there, we drive the cars almost the entire way to their respective furthest nodes (stopping 2 stops before the final node in order to maintain some centrality). At this point, we allow the cars to undergo a random walk where we prioritize traveling to edges that have not yet been explored and, only if none are available, choose a direction at random.","category":"page"},{"location":"discussion/#Performance","page":"Implementation and Performance","title":"Performance","text":"","category":"section"},{"location":"discussion/","page":"Implementation and Performance","title":"Implementation and Performance","text":"Since our algorithm requires a level of randomization, we run the random search multiple times and take the best set of routes in order to ensure that we meet the minimum distance needed. While this does increase the runtime of our algorithm, it does not affect the algorithmic complexity since we run the algorithm a constant number of times.","category":"page"},{"location":"","page":"Docstrings","title":"Docstrings","text":"CurrentModule = HashCode","category":"page"},{"location":"#HashCode-Docstrings","page":"Docstrings","title":"HashCode Docstrings","text":"","category":"section"},{"location":"","page":"Docstrings","title":"Docstrings","text":"Documentation for HashCode.","category":"page"},{"location":"","page":"Docstrings","title":"Docstrings","text":"","category":"page"},{"location":"","page":"Docstrings","title":"Docstrings","text":"Modules = [HashCode]","category":"page"},{"location":"#HashCode.CarPath","page":"Docstrings","title":"HashCode.CarPath","text":"CarPath\n\nA structure representing the path and travel information of a car in the city.\n\nFields:\n\ncarNum (Int): The unique identifier for the car.\npath (Vector{Int}): Vector representing the path of the car, starting with an initial junction.\ntimeTraveled (Int): The total time traveled by the car.\n\nConstructor:\n\nCarPath(carNum::Int): Creates a new CarPath object with the specified car number.\ncarNum: The unique identifier for the car.\n\n\n\n\n\n","category":"type"},{"location":"#HashCode.CityMap","page":"Docstrings","title":"HashCode.CityMap","text":"CityMap\n\nA structure representing the map of a city, including information about nodes (junctions), edges (streets), cars, and visited junctions.\n\nFields:\n\nnodes (Vector{Junction}): Vector of junctions in the city.\nedges (Vector{Street}): Vector of streets connecting junctions.\ncars (Vector{CarPath}): Vector of car paths representing the movement of cars.\nvisitedJuncs (Vector{Int}): Vector of visited junctions.\n\nConstructors:\n\nCityMap(junctions::Vector{Junction}, streets::Vector{Street}): Creates a new CityMap with the given junctions and streets.\njunctions: Vector of Junction objects.\nstreets: Vector of Street objects.\n\nMethods:\n\nnewFunc(): Returns the string \"hi\".\n\n\n\n\n\n","category":"type"},{"location":"#HashCode.DFS-Tuple{HashCode2014.City, Int64, Int64, Int64}","page":"Docstrings","title":"HashCode.DFS","text":"exploreEdgesDFS(city::City, curJunc::Int, curTime::Int, maxTime::Int)\n\nRuns a Depth-First Search (DFS) to find all possible edges that are reachable within the specified time limit. This function serves as a sensible upper bound for the best possible performance with 8 cars, as it calculates the sum of the distances of every reachable node.\n\nParameters:\n\ncity (City): The city object containing information about nodes and edges.\ncurJunc (Int): The current junction from which to find possible next junctions.\ncurTime (Int): The total amount of time that has elapsed up until this recursive call.\nmaxTime (Int): The maximum time limit for the cars to travel.\n\nReturns:\n\nNothing: Modifies a global variable distances, which is a list of distances of reachable edges. The sum of these distances represents the total distance and serves as an upper bound.\n\n\n\n\n\n","category":"method"},{"location":"#HashCode.addCarMove-Tuple{HashCode.CityMap, Int64, Int64}","page":"Docstrings","title":"HashCode.addCarMove","text":"addCarMove(cityMap::CityMap, carNum::Int, juncNum::Int, timeAdded::Int)\n\nUpdates the city map to reflect a car's movement by adding a new junction to its path and updating its total travel time.\n\nParameters:\n\ncityMap (CityMap): The map of the city containing information about cars and visited junctions.\ncarNum (Int): The index of the car making the move.\njuncNum (Int): The junction number to be added to the car's path.\ntimeAdded (Int): The time added to the car's total travel time.\n\nReturns:\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"#HashCode.alreadyVisited-Tuple{HashCode.CityMap, Int64}","page":"Docstrings","title":"HashCode.alreadyVisited","text":"alreadyVisited(cityMap::CityMap, juncNum::Int)\n\nChecks if a junction has already been visited in the city map.\n\nParameters:\n\ncityMap (CityMap): The map of the city containing information about visited junctions.\njuncNum (Int): The junction number to check for.\n\nReturns:\n\nBool: True if the junction has already been visited, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#HashCode.custom_walk-Tuple{HashCode2014.City, Int64}","page":"Docstrings","title":"HashCode.custom_walk","text":"custom_walk(city::City, numTrials::Int)\n\nPerforms a custom walk to generate itineraries for vehicles in a given city.\n\nParameters:\n\nrng (AbstractRNG): The random number generator.\ncity (City): The city information containing details such as total duration, number of cars, starting junction, and streets.\n\nReturns:\n\nTrialResults: A list of the results from running numTrials trials\n\n\n\n\n\n","category":"method"},{"location":"#HashCode.djk-Tuple{HashCode2014.City, Int64}","page":"Docstrings","title":"HashCode.djk","text":"djk(city::City, startJunc::Int)\n\nDjikstra's algorithm to identify the shortest path from the start point to every other node in the graph. Uses standard Djikstra's implementation\n\nParameters:\n\ncity (City): The city object containing information about nodes and edges.\nstartJunc (junction): junction at which to start the search\n\nReturns:\n\ndistances: returns vector that contains the minimum distance from the start node to each of the other nodes in the graph\nprevious: returns a vector that, for each node, has the previous node that would go in front of it in the shortest path   this is done in standard djikstra formulation.\n\n\n\n\n\n","category":"method"},{"location":"#HashCode.findMaximumEndpoints-Tuple{}","page":"Docstrings","title":"HashCode.findMaximumEndpoints","text":"findMaximumEndpoints()\n\nScans through each of the junctions in the city graphs and identitifies the furtherest point in each of the 8 cardinal directions\n\nParameters: None\n\nReturns:\n\nList of the most extreme junctions in each of the cardinal directions that will serve as the target points for each of the 8 cars\n\n\n\n\n\n","category":"method"},{"location":"#HashCode.getCarLocation-Tuple{HashCode.CarPath}","page":"Docstrings","title":"HashCode.getCarLocation","text":"getCarLocation(car::CarPath)\n\nGets the current location of a car based on its path.\n\nParameters:\n\ncar (CarPath): The car path object containing information about the car's path.\n\nReturns:\n\nAny: The current location of the car.\n\n\n\n\n\n","category":"method"},{"location":"#HashCode.getCarLocation-Tuple{HashCode.CityMap, Int64}","page":"Docstrings","title":"HashCode.getCarLocation","text":"getCarLocation(cityMap::CityMap, carNum::Int)\n\nGets the current location of a specified car in the city map.\n\nParameters:\n\ncityMap (CityMap): The map of the city containing information about cars.\ncarNum (Int): The index of the car for which to retrieve the location.\n\nReturns:\n\nAny: The current location of the specified car.\n\n\n\n\n\n","category":"method"},{"location":"#HashCode.getJuncOptions-Tuple{HashCode2014.City, Int64}","page":"Docstrings","title":"HashCode.getJuncOptions","text":"getPosJuncs(city::City, curJunc::Int)\n\nFinds the possible junctions and their durations reachable from the given current junction in a city map.\n\nParameters:\n\ncity (City): The city object containing information about nodes and edges.\ncurJunc (Int): The current junction from which to find possible next junctions.\n\nReturns:\n\nVector{Tuple{Int, Int}}: A vector of tuples representing possible next junctions and their corresponding distances and durations.\n\n\n\n\n\n","category":"method"},{"location":"#HashCode.getMinUnseen-Tuple{Set{Int64}, Vector{Int64}}","page":"Docstrings","title":"HashCode.getMinUnseen","text":"getMinUnseen(unseenNodes, distances)\n\nHelper function for Djikstra's algorithm. Given a set of unseen nodes and the djikstra's distances vector,  identifies the minimum distance node to use next in the search.\n\nParameters:\n\nunseenNodes: set of unseen/unvisited nodes that we must choose from\ndistances: djikstra style distances vector that has the current mininum distance to each node\n\nReturns:\n\nminNode: node that has the minimum current distance amoung unvisited nodes\n\n\n\n\n\n","category":"method"},{"location":"#HashCode.getPathTime-Tuple{Vector{Int64}, HashCode2014.City}","page":"Docstrings","title":"HashCode.getPathTime","text":"getPathTime(path :: Vector{Int},city :: City)\n\nGiven a path, gets the total time that a car has spent on that path in order to understand how much time the car has left\n\nParameters:\n\npath: list of nodes that form the path that the car has already traveled\ncity: standard city object\n\nReturns:\n\ntotalTime: The total time that the car has already spent traveling\n\n\n\n\n\n","category":"method"},{"location":"#HashCode.getPathToNode-Tuple{Int64, Any}","page":"Docstrings","title":"HashCode.getPathToNode","text":"getPathToNode(endNode::Int, previous)\n\nGiven a node and the previous set, reconstructs the shortest path from the starting point to that end node\n\nParameters:\n\nendNode: node to create the path to\nprevious: a vector that, for each node, has the previous node that would go in front of it in the shortest path\n\nthis is done in standard djikstra formulation.\n\nReturns:\n\nnodeList: list of nodes that form the shortest path from the startpoint (4517) to the node\n\n\n\n\n\n","category":"method"},{"location":"#HashCode.getPosJuncs-Tuple{HashCode.CityMap, Int64}","page":"Docstrings","title":"HashCode.getPosJuncs","text":"getPosJuncs(cityMap::CityMap, curJunc::Int)\n\nFinds the possible junctions and their durations reachable from the given current junction in a city map.\n\nParameters:\n\ncityMap (CityMap): The map of the city containing information about edges.\ncurJunc (Int): The current junction from which to find possible next junctions.\n\nReturns:\n\nVector{Tuple{Int, Int}}: A vector of tuples representing possible next junctions and their corresponding durations.\n\n\n\n\n\n","category":"method"},{"location":"#HashCode.haveTraversed-Tuple{Int64, Tuple{Int64, Int64, Int64}}","page":"Docstrings","title":"HashCode.haveTraversed","text":"haveTraversed(curJunc::Int, posJunc)\n\nChecks if a connection between two junctions has been traversed.\n\nParameters:\n\ncurJunc (Int): The current junction.\nposJunc (Tuple{Int, Int}): A tuple representing a possible next junction and its duration.\n\nReturns:\n\nBool: True if the connection has not been traversed, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#HashCode.isFeasible-Tuple{HashCode2014.Solution, HashCode2014.City}","page":"Docstrings","title":"HashCode.isFeasible","text":"isFeasible(solution::HashCode2014.Solution, city::HashCode2014.City)\n\nChecks the feasibility of a given solution within the context of the provided city.\n\nParameters:\n\nsolution (HashCode2014.Solution): The solution to be checked for feasibility.\ncity (HashCode2014.City): The city object containing information about nodes and edges.\n\nReturns:\n\nBool: True if the solution is feasible within the given city, False otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#HashCode.laterRandomWalk-Tuple{Vector{Int64}, HashCode2014.City}","page":"Docstrings","title":"HashCode.laterRandomWalk","text":"laterRandomWalk(previous :: Vector{Int}, city:: Int)\n\nGiven the results of the djikstra algorithm, travels the cars to the endpoints and then random walks them around the area to cover the most distance possible\n\nParameters:\n\nprevious: a vector that, for each node, has the previous node that would go in front of it in the shortest path\n\nthis is done in standard djikstra formulation.\n\ncity: standard city object containing information about the junctions and streets\n\nReturns:\n\nitineraries: set of num_cars itineraries that represent the suggest paths for each car to be used in the solution\n\n\n\n\n\n","category":"method"}]
}
